Index: server/server.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/rpc\"\n\t\"os\"\n\n\t\"uk.ac.bris.cs/gameoflife/stubs\"\n\t\"uk.ac.bris.cs/gameoflife/util\"\n)\n\nvar pause bool\nvar quit bool\nvar kill bool = false\nvar waitToUnpause chan bool\n\n// updateBroker\nvar turnChan chan int\nvar worldChan chan [][]uint8\n\n// updateWorker\nvar workerTurnChan chan int\nvar workerWorldChan chan [][]uint8\n\nvar turnInternal chan int\nvar worldInternal chan [][]uint8\n\nvar workerId int\nvar nextAddr string\nvar globalWorld [][]uint8\nvar completedTurns int\nvar incr int\nvar resume chan bool\nvar done chan bool\n\nfunc getOutboundIP() string {\n\tconn, _ := net.Dial(\"udp\", \"8.8.8.8:80\")\n\tdefer conn.Close()\n\tlocalAddr := conn.LocalAddr().(*net.UDPAddr).IP.String()\n\treturn localAddr\n}\n\nfunc mod(a, b int) int {\n\treturn (a%b + b) % b\n}\n\nfunc calculateNeighbours(height, width int, world [][]byte, y int, x int) int {\n\n\th := height\n\tw := width\n\tnoOfNeighbours := 0\n\n\tneighbour := []byte{world[mod(y+1, h)][mod(x, w)], world[mod(y+1, h)][mod(x+1, w)], world[mod(y, h)][mod(x+1, w)],\n\t\tworld[mod(y-1, h)][mod(x+1, w)], world[mod(y-1, h)][mod(x, w)], world[mod(y-1, h)][mod(x-1, w)],\n\t\tworld[mod(y, h)][mod(x-1, w)], world[mod(y+1, h)][mod(x-1, w)]}\n\n\tfor i := 0; i < 8; i++ {\n\t\tif neighbour[i] == 255 {\n\t\t\tnoOfNeighbours++\n\t\t}\n\t}\n\n\treturn noOfNeighbours\n}\n\nfunc CalculateNextState(height, width, startY, endY int, world [][]byte) ([][]byte, []util.Cell) {\n\n\tnewWorld := make([][]byte, endY-startY)\n\tflipCell := make([]util.Cell, height, width)\n\tfor i := 0; i < endY-startY; i++ {\n\t\tnewWorld[i] = make([]byte, width)\n\t}\n\n\tfor y := 0; y < endY-startY; y++ {\n\t\tfor x := 0; x < width; x++ {\n\t\t\tnoOfNeighbours := calculateNeighbours(height, width, world, startY+y, x)\n\t\t\tif world[startY+y][x] == 255 {\n\t\t\t\tif noOfNeighbours < 2 {\n\t\t\t\t\tnewWorld[y][x] = 0\n\t\t\t\t\tflipCell = append(flipCell, util.Cell{X: x, Y: startY + y})\n\t\t\t\t} else if noOfNeighbours == 2 || noOfNeighbours == 3 {\n\t\t\t\t\tnewWorld[y][x] = 255\n\t\t\t\t} else if noOfNeighbours > 3 {\n\t\t\t\t\tnewWorld[y][x] = 0\n\t\t\t\t\tflipCell = append(flipCell, util.Cell{X: x, Y: startY + y})\n\t\t\t\t}\n\t\t\t} else if world[startY+y][x] == 0 && noOfNeighbours == 3 {\n\t\t\t\tnewWorld[y][x] = 255\n\t\t\t\tflipCell = append(flipCell, util.Cell{X: x, Y: startY + y})\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newWorld, flipCell\n}\n\ntype GolOperations struct{}\n\nfunc UpdateBroker(tchan chan int, wchan chan [][]uint8, client *rpc.Client) {\n\tfor {\n\t\tt := <-tchan\n\t\tws := <-wchan\n\t\ttowork := stubs.UpdateRequest{Turns: t, World: ws, WorkerId: workerId}\n\t\tstatus := new(stubs.StatusReport)\n\t\terr := client.Call(stubs.UpdateBroker, towork, status)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"RPC client returned error:\")\n\t\t\tfmt.Println(err)\n\t\t}\n\t}\n}\n\nfunc (s *GolOperations) Action(req stubs.StateRequest, res *stubs.StatusReport) (err error) {\n\tswitch req.State {\n\tcase stubs.Pause:\n\t\tpause = true\n\tcase stubs.UnPause:\n\t\tpause = false\n\t}\n\treturn nil\n}\n\nfunc (s *GolOperations) ActionWithReport(req stubs.StateRequest, res *stubs.StatusReport) (err error) {\n\tswitch req.State {\n\tcase stubs.Quit:\n\t\tquit = true\n\t\tfmt.Println(\"pause\")\n\tcase stubs.Save:\n\tcase stubs.Kill:\n\t\tkill = true\n\t\tdefer os.Exit(0)\n\t}\n\treturn nil\n}\n\nfunc (s *GolOperations) UpdateWorker(req stubs.UpdateRequest, res *stubs.StatusReport) (err error) {\n\n\tglobalWorld = req.World\n\tcompletedTurns = req.Turns\n\tres.Status = 7\n\tincr++\n\treturn\n}\n\nfunc worker(p stubs.Params, startY, endY, startX, endX int, world [][]uint8, out chan<- [][]uint8, turn int) {\n\tnewPart := make([][]uint8, endY-startY)\n\tfor i := range newPart {\n\t\tnewPart[i] = make([]uint8, endX)\n\t}\n\tnewPart, _ = CalculateNextState(p.ImageHeight, p.ImageWidth, startY, endY, world)\n\tout <- newPart\n}\n\nfunc (s *GolOperations) Process(req stubs.WorkerRequest, res *stubs.Response) (err error) {\n\tworkerId = req.WorkerId\n\tvar newWorldSlice [][]uint8\n\tglobalWorld = req.World\n\tpause = false\n\tquit = false\n\tturn := 0\n\tincr = 0\n\t// HARDCODE NO OF THREADS ON THE --SERVER SIDE'S WORKER--\n\tdistThreads := 2\n\tfor t := 0; t < req.Turns; t++ {\n\t\tif incr == t && !pause && !quit {\n\t\t\tif pause {\n\t\t\t\tfmt.Println(\"Paused\")\n\t\t\t}\n\t\t\tif !kill {\n\t\t\t\tif distThreads == 1 {\n\t\t\t\t\tnewWorldSlice, _ = CalculateNextState(req.Params.ImageHeight, req.Params.ImageWidth, req.StartY, req.EndY, globalWorld)\n\t\t\t\t\tturn++\n\t\t\t\t\tturnChan <- turn\n\t\t\t\t\tworldChan <- newWorldSlice\n\t\t\t\t} else {\n\t\t\t\t\tvar worldFragment [][]uint8\n\t\t\t\t\tchannels := make([]chan [][]uint8, distThreads)\n\t\t\t\t\tunit := int((req.EndY - req.StartY) / distThreads)\n\t\t\t\t\tfor i := 0; i < distThreads; i++ {\n\t\t\t\t\t\tchannels[i] = make(chan [][]uint8)\n\t\t\t\t\t\tif i == distThreads-1 {\n\t\t\t\t\t\t\t// Handling with problems if threads division goes with remainders\n\t\t\t\t\t\t\tgo worker(req.Params, req.StartY+(i*unit), req.EndY, 0, req.Params.ImageWidth, globalWorld, channels[i], turn)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgo worker(req.Params, req.StartY+(i*unit), req.StartY+((i+1)*unit), 0, req.Params.ImageWidth, globalWorld, channels[i], turn)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor i := 0; i < distThreads; i++ {\n\t\t\t\t\t\tworldPart := <-channels[i]\n\t\t\t\t\t\tworldFragment = append(worldFragment, worldPart...)\n\t\t\t\t\t}\n\t\t\t\t\tturn++\n\t\t\t\t\tturnChan <- turn\n\t\t\t\t\tworldChan <- worldFragment\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tif kill {\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tt--\n\t\t}\n\t}\n\tres.World = newWorldSlice\n\tres.TurnsDone = turn\n\treturn\n}\n\nfunc main() {\n\tpAddr := flag.String(\"port\", \"8050\", \"Port to listen on\")\n\tbrokerAddr := flag.String(\"broker\", \"127.0.0.1:8030\", \"Address of broker instance\")\n\tflag.Parse()\n\tclient, err := rpc.Dial(\"tcp\", *brokerAddr)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\trpc.Register(&GolOperations{})\n\tlisteners, err := net.Listen(\"tcp\", \":\"+*pAddr)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tsubscribe := stubs.SubscribeRequest{\n\t\tWorkerAddress: getOutboundIP() + \":\" + *pAddr,\n\t}\n\tturnChan = make(chan int)\n\tturnInternal = make(chan int)\n\tworldChan = make(chan [][]uint8)\n\tworldInternal = make(chan [][]uint8)\n\twaitToUnpause = make(chan bool)\n\n\tclient.Call(stubs.ConnectWorker, subscribe, new(stubs.StatusReport))\n\n\tdefer listeners.Close()\n\tgo UpdateBroker(turnChan, worldChan, client)\n\trpc.Accept(listeners)\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/server/server.go b/server/server.go
--- a/server/server.go	(revision 171a991e67e525cbd840a9e372b82d59c2f17668)
+++ b/server/server.go	(date 1670778329752)
@@ -165,9 +165,6 @@
 	distThreads := 2
 	for t := 0; t < req.Turns; t++ {
 		if incr == t && !pause && !quit {
-			if pause {
-				fmt.Println("Paused")
-			}
 			if !kill {
 				if distThreads == 1 {
 					newWorldSlice, _ = CalculateNextState(req.Params.ImageHeight, req.Params.ImageWidth, req.StartY, req.EndY, globalWorld)
